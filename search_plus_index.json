{"./":{"url":"./","title":"簡介","keywords":"","body":"簡介 這裡記錄學習筆記 "},"back-end/java/":{"url":"back-end/java/","title":"Java","keywords":"","body":"Java 特色 跨平台 簡單 物件導向 安全 穩定的 非常重視型別(strong-type) 使用列舉型別(enum)、泛型(generic)等功能在程式編譯時即檢查出型態問題 提供記憶體回收功能，較不會有OutOfMemory狀況發生 多執行緒 "},"back-end/java/javabase/":{"url":"back-end/java/javabase/","title":"基礎Java","keywords":"","body":"基礎Java "},"back-end/java/javabase/variable.html":{"url":"back-end/java/javabase/variable.html","title":"變數","keywords":"","body":"Variable 變數型別 Java的型別分為兩大類： 基本型別(Primitive Type) 參考型別(Reference Type) 基本型別 基本型別共八種： 類型 型別 位元組 位元數 整數 byte 1 8 整數 short 2 16 整數 int 4 32 整數 long 8 64 浮點數 float 32-bit 浮點數 double 64-bit 字元 char 2 16 布林值 boolean 1 8 變數的有效範圍 實體變數(Instance variable)，亦即類別屬性或欄位 有效範圍在整個實例(instance)內 使用前若未給值(未初始化)，將依其型別給予預設值： 型別分類 基本型別 預設值 整數 byte、short、int、long 0 浮點數 float、double 0.0 字元 char 空字元，為'' or '\\u0000' 邏輯 boolean false 區域變數(Local variable) 有效範圍在宣告的方法或特定程式碼{}內。若變數名稱和外圍變數名稱相同，區域變數會覆蓋實例變數 宣告的型態前面不能再加public等修飾詞 使用前若未給值(初始化)，將會編譯失敗 型別的升等與轉型 升等：小型別會自動提升為與大型別一致 轉型：通常用於將大型別轉成小型別 語法：(target_type)value "},"back-end/java/javabase/referencetype.html":{"url":"back-end/java/javabase/referencetype.html","title":"參考型別","keywords":"","body":"參考型別 使用物件參考 利用類別(class)建立並使用物件(object) 有如遙控器的概念 要使用「物件」，必須使用該物件的「物件參考變數」(簡稱「物件參考」或「參考變數」) 概念上有如「電子產品」由「遙控器」遠端操控 名稱 概念 舉例 物件參考變數 遙控器 myPen 物件 電子產品 Pen 由類別(class)建構物件 建構物件有三個程序： 宣告(Declaration) 語法：ClassName reference(物件參考變數); 實體化(Instantiation) 語法：new ClassName; 將實體指定給物件參考，完成初始化(Initialization) 語法：reference = new ClassName // 1. 宣告 Book myBook; // Book為類別名稱 // myBook為物件參考變數 // 2. 實體化 new Book(); // Book為類別名稱，將使用該類別產生物件實體 // 3. 初始化 myBook = new Book(); // 因無法直接碰觸記憶體裡的Book物件，故使用物件參考myBook來控制 // 完整程序： Book myBook = new Book(); 比較基本型別和參考型別的變數宣告： 項目 型別 變數 指派運算子 記憶體內容 基本型別範例 int x = 10 參考型別範例 Book myBook = new Book() 對不同物件使用不同物件參考 不同種類物件，即使同種但不同的物件，都該使用各自的物件參考(遙控器)來對物件進行控制： Book myBook1 = new Book; myBook1.publishing(); Book myBook2 = new Book; myBook2.publishing(); Pen myPen = new Pen(); myPen.write(); 目前以上例來說，「宣告型別(reference type)」與所參照的「物件型態(object type)」都相同，兩者均為Book，實際上並不需要相同。以遙控器的比喻來說，目前一種遙控器只能控制一種裝置，但實務上有通用遙控器，經過一些設定後就能控制同種但不同品牌的電子產品，即為「多型」的概念。 JVM記憶體分類 Java記憶體分三大區塊： Global(全域) 保存static的類別成員變數的地方 Stack(堆疊) 保存基本型別(primitive type)的變數和變數內容(value)的地方 保存參考型別(reference type)的變數的地方 Heap(堆積) 保存參考型別(reference type)的變數內容(instance)的地方 Stack和Heap歸納如下： 分類 變數&變數值 Stack Heap 基本型別 變數 O 基本型別 值 O 參考型別 變數(物件參考\b) O 參考型別 值(物件實體) O 使用String類別 String類別屬於參考型別，使用時會產生物件 String物件可以不使用new關鍵字進行實體化，好處是透過字串池避免記憶體浪費 String類別的其他方法 方法 功能 length() 取得字串長度 toUpperCase() / toLowerCase() 將字串內的字元全部轉換為大寫或小寫 trim() 去除字串前後空白 substring() 由字串內取出全部字串 endsWith() 判斷字串結尾 String.join() JDK8新增方法--拼接，第一個參數為拼接符號，第二個參數為陣列或集合 substring()範例 //回傳包含index本身的後面字元(index從0開始) \"unhappy\".substring(2) returns \"happy\" \"Harbison\".substring(3) returns \"bison\" \"emptiness\".substring(9) returns \"\" (an empty string) //回傳包含第一個index本身後面到第二個index（不包含）的字元 \"hamburger\".substring(3,8) returns \"burge\" \"smiles\".substring(0,5) returns \"smile\" StringBuilder 基本型別的包覆類別 基本型別 包覆類別 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean "},"back-end/java/javabase/array.html":{"url":"back-end/java/javabase/array.html","title":"陣列","keywords":"","body":"Array 陣列 一維陣列與二維陣列 陣列的基本定義 為一種容器物件(container object)，可裝載多個且單一型態的基本型別或參考型別（比較：ArrayList只可放參考型別的物件） 陣列裡的內容物稱為成員(element) 建立時必須指定長度，即成員數量；建立後長度即不能改變 陣列的成員使用數字化的索引(index)存取，第一個成員的index為0 建立一維陣列 陣列也是物件，因此建立陣列的完整程序也分下列三部分： 第一部分：宣告 type [] array_identifier; // type:陣列的成員型別 // []:表示宣告陣列 // array_identifier:陣列名稱 第二部分：建構實體 array_identifier = new type [length]; 第三部分：初始化 array_identifier[index] = value; // index:成員位置，從0開始，最大長度為「長度 - 1」 可將上述三個程序一次完成(前提為程式碼不能分行)： type [] array_identifier = {成員以\",\"區隔}; ArrayList類別 陣列的缺點 陣列無法自動增加長度，有諸多不便： 紀錄每個加入陣列的元素的索引 追蹤並記錄陣列長度 若長度不足，則必須建立一個足夠長度的新陣列，並將原陣列成員逐一複製過去，再捨棄原陣列 ArrayList類別簡介 只存放參考型別的物件，不接受基本型別；但可以改用基本型別的包覆類別 有許多方法可以管理成員物件：add()、get()、remove()、indexOf()等 建構ArrayList物件時不需要設定長度大小，當需要加入更多成員物件時，將自動成長 在建構ArrayList物件時可設定initial capacity，但不強制 "},"back-end/java/javabase/Method.html":{"url":"back-end/java/javabase/Method.html","title":"方法","keywords":"","body":"使用方法 宣告static方法和變數 若在屬性或方法前加上static修飾詞，則該屬性或方法使用時就不需要再透過物件生成 亦即直接使用類別，就能呼叫static方法和變數 沒有static時的困境 使用static解決問題 package course.c10; public class Circle1 { private double radius; static final double PI = 3.1415926; public void setRadius(double r) { this.radius = r; } // public double getArea() { return this.radius * this.radius * PI; } // 此為公式，結果只和輸入參數有關 static double areaFormula(double r) { return r * r * PI; } public static void main(String[] args) { System.out.println(Circle1.PI); // 圓半徑為1，求面積 System.out.println(Circle1.areaFormula(1)); // 圓半徑為10，求面積 System.out.println(Circle1.areaFormula(10)); } } static宣告的意義 每個類別只載入一次，故類別成員在JVM裡是唯一存在 物件成員可以呼叫類別成員 類別成員不能出叫物件成員 定義在類別內的所有屬性和方法分兩類： 未使用static宣告 必須先產生物件，再使用物件參考(遙控器)去呼叫 無static宣告的欄位和方法稱為物件成員(object member) 使用static宣告 因為只用類別名稱就可以呼叫方法和欄位，因此稱有static宣告的欄位和方法為類別成員(class member) static宣告的時機 public class Circle2 { private double radius; public void setRadius(double r) { this.radius = r; } public double getArea() { return areaFormula(this.radius); } // 此為公式，結果只和輸入參數有關 static double areaFormula(double r) { return r * r * Math.PI; } } 建立多載的方法 方法的簽名 方法名稱及參數合併稱為方法簽名(method signature) 就像用簽名識別身份，方法不只用方法名稱識別，還要加上參數 認定方法參數是否相同有三個考量： 數量 順序 型別 方法的多載 同一個類別內，若有方法名稱相同，但簽名不同(否則無法編譯)，就稱為多載(Overloading) 使用時機： 若類別內有多個方法功能相近，只是傳入的參數型態、數量不同，就可以使用多載進行coding 變數值的傳遞 變數值傳遞的發生場景 Java在兩種情況時需要傳遞(pass)變數/參數： 由指定運算子「=」右側，將值(value)傳遞給左側變數 透過方法宣告的參數，將值由呼叫者(caller)方法傳遞進入工作者(worker)方法中 Java使用「Pass by Value」來傳遞變數/參數 Pass by Value 參考型別 若變數屬於參考型別，則複製物件參考(遙控器)後進行傳遞。複製前後雖然是不同遙控器，但指向同一物件 基本型別 因為沒有遙控器的概念，因此是直接複製變數值，如同影印機複製原稿後產生副本，兩者各自獨立 "},"back-end/java/javabase/OOP/":{"url":"back-end/java/javabase/OOP/","title":"繼承","keywords":"","body":"進階OOP設計 繼承 繼承的主要目的： 子類別繼承父類別後，可取得父類別的屬性及方法，故程式碼可重複使用 多個類別若有相似的code，可將相同部分抽出後建立父類別，再以繼承父類別方式共用code 使用this及super關鍵字呼叫建構子 建構子非物件成員(屬性及方法)，故無法繼承，有兩種方法取得： 若未建立建構子，則有預設的無參數建構子 已建立建構子，若仍須無參數建構子則須再建立 在類別內呼叫自己或父類別的建構子並非使用建構子名稱，而是： 存取自己的建構子：使用this()傳入參數 存取父類別的建構子：使用super()傳入參數 建構子的設計原則 物件實體化的過程裡，為了讓子類別可以取得父類別的屬性和方法，必須先執行父類別建構子的內容，在執行子類別建構子的內容 為了達成此原則，Java採取： 每個子類別的建構子內容，執行時的第一個動作都必須呼叫一個父類別的建構子 Reference 繼承(Inheritance)-建構子(Constructor) 概念與實例 "},"back-end/java/javabase/constructor.html":{"url":"back-end/java/javabase/constructor.html","title":"封裝及建構子","keywords":"","body":"使用封裝和建構子 封裝：用來資訊隱藏、實現多型的必要手段 建構子：會在物件建構過程中被Java呼叫，故名。主要用來初始化物件的屬性欄位 使用建構子 建立建構子 建構子和類別成員「方法」的宣告和實作方式都很像，但有關鍵性的不同： 建構子名稱必須和class名稱一樣 沒有回傳，也不是void 建構子若要多載，只能用不同參數創建 語法 [modifiers] class ClassName { [modifiers] ClassName ([arguments]){ code_block } } // 第一個ClassName是類別名稱 // 第二個ClassName是建構子名稱 使用建構子建立新物件 參考型別物件建立的第二步驟實體化的語法為new ClassName(); 在new關鍵字後面的類別名稱即為建構子 故所謂實體化，就是使用new關鍵字來呼叫建構子，完成記憶體空間heap裡的實體建立 若未在類別中建立建立建構子，Java會預設一個無參數的建構子，可直接使用 但若已建立過建構子，則Java即不提供預設建構子，此時以下呼叫就會編譯失敗： Book b1 = new Book(); 已建立其他建構子若仍需使用無參數建構子就要自行建立 chaining constructors:建構子之間(overloading)若要互相呼叫，需使用「this」關鍵字加上參數 chaining constructors範例 各級存取權限比較 同class 同package 不同package但須為子類別 不設限 private Y default Y Y protected Y Y Y public Y Y Y Y 熟悉複寫規則 "},"back-end/java/javabase/object.html":{"url":"back-end/java/javabase/object.html","title":"Object的11個方法","keywords":"","body":"Object中的11個方法 getClass(), hashCode(), equals(), clone(), toString(), finalize(), notify(), notifyAll(), 三個wait() getClass() public final native Class getClass(); hashCode() public native int hashCode(); equals() public boolean equals(Object obj) { return (this == obj);} clone() protected native Object clone() throws CloneNotSupportedException; toString() finalize() protected void finalize() throws Throwable { } notify() public final native void notify(); notifyAll() public final native void notifyAll(); wait(long timeout)() public final native void wait(long timeout) throws InterruptedException; wait(long timeout, int nanos)() wait() public final void wait() throws InterruptedException { wait(0);} "},"back-end/java/javabase/Java8/Lambda.html":{"url":"back-end/java/javabase/Java8/Lambda.html","title":"Lambda","keywords":"","body":"Lambda Lambda精神 不需要為了呼叫一個方法而設計一個完整類別及物件，直接看到方法內容 「=」左邊仍然是以介面作為型別宣告變數，但右邊則由原來的「類別定義」降格為「方法定義」 Lambda的目的即爲用「方法定義」取代「類別定義」 包含三個部分 方法參數 參數的型別宣告可省略 若只有單一參數且已省略型別宣告，則可以再省略() 箭頭符號 方法內容 有{ }：和一般方法內code相同，例如： 若有回傳須加return 每行code以「;」隔開 運算式或表示式須將結果指定給變數，如boolean a = (1 無{ }： 不能加return(因為Java會自動判斷Functional Interface上宣告的抽象方法有沒有回傳) 只有一行code，不需也不能使用「;」斷行 語法Ex 舉例 結果 說明 (int x, int y) -> x + y OK (x, y) -> x + y OK (x, y) -> {System.out.println(X +y );} OK (String s) -> s.contains(\"word\") OK s -> s.contains(\"word\") OK 只有一個參數可省略() () -> true OK a, b -> a.startsWith(\"test\") NG 2個以上參數則()不能省略 a -> { a.startsWith(\"test\"); } OK 方法必須是void a -> { return a.startsWith(\"test\") } NG \b\b\b\b\b\b有{}則code要有「;」 (a, b) -> {int a = 0; return 5;} NG 方法內容的區域變數名稱不能和參數相同 (a, b) -> {int c = 0; return 5;} OK 功能性介面 functionalInterface 搭配@functionalInterfaceannotation 可限定該介面只有一個方法 內建的Functional Interface 評斷型(Predicate)：使用泛型傳入參數，且回傳boolean 消費型(Consumer)：使用泛型傳入參數，且沒有回傳(void) 功能型(Function)：將傳入的參數由T型別轉換成U型別 供應型(Supplier)：如同工廠方法，提供T型別的物件 "},"back-end/java/javabase/collectionsapi.html":{"url":"back-end/java/javabase/collectionsapi.html","title":"collections API","keywords":"","body":"collections API 重要： contains containsAll remove removeAll "},"back-end/java/jdbc.html":{"url":"back-end/java/jdbc.html","title":"JDBC","keywords":"","body":"JDBC 隔離等級 "},"back-end/java/servlet-web/":{"url":"back-end/java/servlet-web/","title":"Servlet Web","keywords":"","body":"Servlet Web 什麼是Servlet 是JavaEE規範之一，規範即介面 為JavaWeb三大組成之一(三大組成：Servlet程序、Filter過濾器、Listener監聽器) 是用Java編寫的伺服器端程式。其主要功能在於互動式地瀏覽和修改資料，生成動態Web內容 動手實作Servlet程序 編寫一個class去實作Servlet介面 實現service方法，處理請求，並回應數據 到web.xml中設定servlet程序的連接位址 常見錯誤1：url-pattern中設置的路徑沒有以/斜線開頭 常見錯誤2：servlet-name設置的值不存在 常見錯誤3：servlet-class名稱錯誤 package ken.servlet.test; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class HelloServlet implements Servlet { @Override public void destroy() { // TODO Auto-generated method stub } @Override public ServletConfig getServletConfig() { // TODO Auto-generated method stub return null; } @Override public String getServletInfo() { // TODO Auto-generated method stub return null; } @Override public void init(ServletConfig arg0) throws ServletException { // TODO Auto-generated method stub } @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println(\"Hello Servlet 已連接\"); } } web.xml: ServletTest index.html index.htm index.jsp default.html default.htm default.jsp HelloServlet ken.servlet.test.HelloServlet HelloServlet /hello url位址如何與servlet程序連接 "},"back-end/java/servlet-web/javabeans.html":{"url":"back-end/java/servlet-web/javabeans.html","title":"JavaBeans","keywords":"","body":"JavaBeans 包裝資料，重複使用 三個特性 必須是一個public類別，且必須有一個不傳入參數的public建構子 取得或設定屬性(properties)時，必須用 getXxx 或 setXxx 的方法 必須是一個可序列化(Serializable)的類別，指 implements java.io.Serializable 空介面 "},"back-end/java/servlet-web/request-parameters.html":{"url":"back-end/java/servlet-web/request-parameters.html","title":"Request Parameters","keywords":"","body":"Request Parameters （請求參數）的傳遞方式 GET 於瀏覽器直接輸入URL時 點選超連結(hyperlink)時 HTML表單(form) POST HTML表單(form) "},"back-end/java/servlet-web/servletlifecycle.html":{"url":"back-end/java/servlet-web/servletlifecycle.html","title":"Servlet 生命週期","keywords":"","body":"Servlet 生命週期 四個生命週期 創建實體 Servlet Reloading (Servlet 重載入) ->例外 Load on Startup (啟動時載入) ->例外 初始化 Init Parameter (初始參數) 服務 Persistence vs Synchronization Single Thread Model (單緒模型)(Deprecated) 卸載 Initial & Destroy (協同運作) 生命週期基本概念 Servlet container: 替我們建立servlet實體，並由其控制呼叫servlet的init(), service(), destroy()等方法，以管理servlet的生命週期 程式設計師：則藉由提供上述方法之實作，予以控制該servlet物件及與該物件相關之resource 背景執行緒 "},"back-end/java/servlet-web/webxml.html":{"url":"back-end/java/servlet-web/webxml.html","title":"web.xml部署檔","keywords":"","body":"web.xml部署檔 這個是應用程式部屬的描述檔，一定放在web.xml下，簡單來說，這個是用來起始程式的開始點. hi HelloWorld hi /hello.html hi /hello.html/* hi *.mm servlet開始，servlet結束 servlet-name servlet-class servlet-mapping開始，servlet-mapping結束 servlet-name url-pattern "},"back-end/java/servlet-web/synchronization.html":{"url":"back-end/java/servlet-web/synchronization.html","title":"同步化","keywords":"","body":"同步化 第三種不可用 第一種效能最差，但都用這種，因為安全簡便 第三種效能最好 專案開發時，區域變數優先 "},"back-end/java/servlet-web/reloading.html":{"url":"back-end/java/servlet-web/reloading.html","title":"Servlet重載入","keywords":"","body":"Servlet重載入 有一支重載入，大家都重載入 會呼叫每一支的destroy 因換了新的類別載入器(class loader) "},"back-end/java/servlet-web/date.html":{"url":"back-end/java/servlet-web/date.html","title":"Date","keywords":"","body":"Date Calendar 10顆星重要：getTime() "},"back-end/java/servlet-web/servletinterface.html":{"url":"back-end/java/servlet-web/servletinterface.html","title":"Servlet Interface","keywords":"","body":"Servlet Interface Servlet destroy() init(ServletConfig config)) service(ServletRequest req, ServletResponse res) ServletConfig getInitParameter(String name) getInitParameterNames() getServletContext() getServletName() "},"back-end/java/servlet-web/session.html":{"url":"back-end/java/servlet-web/session.html","title":"Session機制","keywords":"","body":"Session機制 什麼是Session 是一種紀錄用戶端狀態的機制 儲存在伺服器上 Session相當於程式在伺服器上建立的一份客戶檔案，客戶來訪時只需查詢客戶檔案表即能追蹤 實現使用者登入 對應的類別為javax.servlet.http.HttpSession類別 每個來訪者對應一個Session物件，所有該客戶的狀態資訊都儲存在這個Session物件裡 Session物件在用戶端第一次請求伺服器時建立 Session是一種key-value屬性對，透過getAttribute(String key)及setAttribute(String key, Object value)方法讀寫客戶狀態資訊 透過request.getSession()獲得該客戶的Session，如： // 獲得Session物件 HttpSession session = request.getSession(); // 設定Session中的屬性 session.setAttribute(\"loginTime\", new Date()); // 獲得Session屬性 out.println(\"登入時間為：\" + (Date)session.getAttribute(\"loginTime\")); HttpSession介面之屬性(Attribute)方法 void session.setAttribute(String name, Object value) 將指定的物件存入session中 Object session.getAttribute(String name) 從session中取出物件 void session.removeAttribute(String name) 從session中移除物件 Enumeration session.getAttributeNames() 將目前session中的所有屬性名稱以Enumeration型態傳回 程式片段(取得session擁有之所有屬性名稱、值) Enumeration en = session.getAttributeNames(); while (en.hasMoreElements()){ String name = (String) en.nextElement(); out.println(name + \":\" + session.getAttribute(name)); } HttpSession介面其他方法 "},"back-end/SQL/":{"url":"back-end/SQL/","title":"Oracle SQL","keywords":"","body":"Oracle SQL "},"back-end/SQL/groupBy.html":{"url":"back-end/SQL/groupBy.html","title":"GROUP BY","keywords":"","body":"GROUP BY 群組化表格資料，可以用來搭配聚合函數 聚合函數 可以執行所選取的欄位值的筆數、平均、統計等，以便資料分析 聚合函數 作用 Count 取得欄位資料筆數 Sum 取得欄位資料總和 Max 取得欄位資料最大值 Min 取得欄位資料最小值 Avg 取得欄位資料平均值 EX1 -- SELECT列出來的欄位，除了聚集函數的欄位外，其餘都要列在GROUP BY條件中，否則會不符合閱讀邏輯 -- 如把 Author 從GROUP BY拿掉就會出錯 SELECT PUBLISHER_ID, AUTHOR, COUNT(BOOK_NAME) AS BOOK_COUNT FROM BOOK GROUP BY PUBLISHER_ID, AUTHOR ORDER BY BOOK_COUNT DESC; EX2 --查部門最高薪、最低薪 SELECT DNAME 部門名, MAX(SAL) 最高薪水, MIN(SAL) 最低薪水 FROM EMP2 E JOIN DEPT2 D ON E.DEPTNO = D.DEPTNO GROUP BY DNAME; --查部門平均薪資 SELECT DNAME, ROUND(AVG(SAL)) 平均薪資 FROM EMP2 E JOIN DEPT2 D ON E.DEPTNO = D.DEPTNO GROUP BY DNAME; --查部門人數 SELECT DNAME, COUNT(ENAME) 部門人數 FROM EMP2 E JOIN DEPT2 D ON E.DEPTNO = D.DEPTNO GROUP BY DNAME; References SQL Group By "},"Tools/Junit.html":{"url":"Tools/Junit.html","title":"JUnit","keywords":"","body":"JUnit JUnit四大核心 TestCase / 測試案例 @Test @Before — 在每個Test Method之前都會執行一次。 @After — 在每個Test Method之後都會執行一次。 @BeforeClass — 每個Test Class建構者執行後都會執行一次。 @AfterClass — 每個Test Class建構者執行後都會執行一次。 @Ignore — 忽略此單元測試，(若在單元測試class中方法沒加上Ignore，JUnit會執行失敗) TestResult / 測試結果 TestSuite / 測試組合 Assert / 斷言(參閱如下：Assert常用API) Assert常用API assertEquals // 判斷2個物件是否相等 assertNotEquals // 判斷2個物件是否不相等 assertTrue // 驗證是否為真 assertNull // 驗證物件是否為null assertNotNull // 驗證物件是否不為null assertArrayEquals // 驗證陣列是否相同 "},"Tools/vim.html":{"url":"Tools/vim.html","title":"Vim","keywords":"","body":"Vim 操作 Example: #! /usr/bin/bash echo \"The script name is ==> ${0}\" echo \"Total parameter number is ==> $#\" [ \"$#\" -lt 2 ] && echo \"Parameter is less than 2.\" && exit 0 echo \"Your whole parameter is ==> '$@'\" total=$((${1}+${2})) echo The sum is : ${total} "},"Tools/Terminal.html":{"url":"Tools/Terminal.html","title":"Linux指令","keywords":"","body":"Linux 指令 常用系統指令 指令 說明 cd 切換目錄 pwd 顯示目前所在目錄 ls 列出目前檔案列表 mkdir 建立新的目錄 touch 建立檔案 cp 複製檔案 rm 刪除檔案 mv 移動檔案 clear 清除畫面內容 ls-列出目錄下的檔案 指令 說明 ls 列出基本資料夾資料 -l 列出詳細資料 -a 列出所有包含隱藏資料 ls *.py 列出為.py的檔案 檔案處理 刪除目前資料夾下副檔名為.js檔案 $ rm *.js 刪除資料夾（包括在內的檔案） $ rm -rf /Users/folder1 cat:將文件印在Terminal $ cat README.md tail:顯示檔案最後幾行內容 $ tail README.md 持續顯示更新內容（常應用於web server看lod debug使用 tail -f README.md Linux檔案系統標準 /bin、/sbin /bin放置一般使用者可操作的指令 /sbin放置系統管理員可操作的指令 /etc 放置系統檔案 /home、/root /home 主要是一般帳戶的家目錄 /root 為系統管理者的家目錄 /lib、/lib64 主要為系統函式庫和核心函式庫 /proc 將記憶體內的資料做成檔案類型 /sys 與 /proc 類似，但主要針對硬體相關參數 /usr 全名為unix software resource，放置系統相關軟體、服務 /media、/mnt 放置隨插即用的裝置慣用目錄， /mnt 為管理員/使用者手動掛上 （mount）的目錄 /opt - 全名為optional，通常為第三方廠商放置軟體處 查找檔案及其內容 在目前目錄下尋找檔名為README.md的檔案 $ find . -name README.md grep:文件字串搜尋工具 $ grep '找這個字串' file_name 找所有目錄（含子目錄）下檔案 $ grep -r '字串' References https://kim85326.github.io/2019/01/16/Terminal-指令/ 待整理 df -h 看硬碟容量 lsblk -p mskf? 格式化 "},"back-end/developing-solutions/":{"url":"back-end/developing-solutions/","title":"Developing Solutions","keywords":"","body":"Developing Solutions 敏捷開發(Agile) "},"back-end/developing-solutions/solid-she-ji-yuan-ze.html":{"url":"back-end/developing-solutions/solid-she-ji-yuan-ze.html","title":"SOLID設計原則","keywords":"","body":"SOLID設計原則 單一職責原則(Single responsibility principle, SRP) 一個模組應該只對唯一的一個角色負責。 開放封閉原則(Open-Close principle, OCP) 一個軟體製品應該對於擴展是開放的，但對於修改是封閉的。 里氏替換原則(Liskov substitution principle, LSP) 建置軟體系統必須來自於可互換的部分，這些部分必須遵守允許這些部分相互替換的契約。 介面隔離原則(Interface segregation principle, ISP) 此原則建議軟體設計者避免依賴於他們不使用的東西。 依賴反向原則(Dependency inversion principle, DIP) 實作策略的高層級程式碼不應該依賴於實作細節的低層級程式碼。相反地，細節應該依賴於策略。 "},"back-end/developing-solutions/design-pattern/":{"url":"back-end/developing-solutions/design-pattern/","title":"Design Pattern","keywords":"","body":"Design Pattern GOF的設計模式有23個： 策略模式 觀察者模式 "},"back-end/developing-solutions/design-pattern/ce-lve-mo-shi.html":{"url":"back-end/developing-solutions/design-pattern/ce-lve-mo-shi.html","title":"策略模式","keywords":"","body":"策略模式 優點： 缺點： "},"back-end/developing-solutions/uml.html":{"url":"back-end/developing-solutions/uml.html","title":"UML","keywords":"","body":"UML Association Inheritance Implementation Dependency Aggregation Composition "},"back-end/developing-solutions/agile/":{"url":"back-end/developing-solutions/agile/","title":"Agile","keywords":"","body":"Agile 漸增模式(Incremental Model) 敏捷開發(Agile Development) 敏捷宣言(Agile Manifesto) 敏捷開發的12個原則 我們最優先的任務，是透過及早並持績地交付有價值的軟體來滿足客戶需求。 竭誠歡迎改變需求，甚至已處開發後期亦然。敏捷流程掌控變更，以維護客戶的競爭優勢。 經常交付可用的軟體，頻率可以從數週到數個月，以較短時間間隔為佳。 業務人員與開發者必須在專案全程中天天一起工作。 以積極的個人來建構專案，給予他們所需的環境與支援，並信任他們可以完成工作。 面對面的溝通是傳遞資訊給開發團隊及團隊成員之間效率最高且效果最佳的方法。 可用的軟體是最主要的進度量測方法。 敏捷程序提倡可持續的開發。贊助者、開發者及使用者應當能不斷地維持穩定的步調。 持續追求優越的技術與優良的設計，以強化敏捷性。 精簡─或最大化未完成工作量之技藝─是不可或缺的。 最佳的架構、需求與設計皆來自於能自我組織的團隊。 團隊定期自省如何更有效率，並據之適當地調整與修正自己的行為。 Agile開發相關問答 敏捷開發重視的是什麼？ 個人與互動 可用的軟體 與客戶合作 回應變化 附加在User Story之Acceptance Test，其： 主要目的：描述User Story的細節，設定User Story是否完成的標準 由誰負責撰寫：客戶方 什麼時候撰寫：於Coding之前撰寫 使用User Story的敏捷開發，何謂3C？ Card Conversation Confirmation 需求評估所使用之Kano模型，將需求分為哪三類？ 基本型 期望型 魅力型 估算使用者故事大小，最常用的方法？ Planning Poker 估算使用者故事大小，最常用的單位？ 故事點 理想工作天 在Release Planning時，有哪兩種不同的驅動方式？ Date-Driven Feature-Driven UML全稱 Unified Modeling Language UML統一： 統一了Notation 沒有統一Process UML主要用途： modeling write software blueprint visualization, specification, construction, documentation 使用瀑布模式有何缺點？ 使用者需求不詳盡，導致後續階段的不確定性 太慢讓使用者看到系統，可能導致系統不合使用者需求 初始階段錯誤會導致連鎖反應，使損失擴大效果 相對瀑布模式，使用漸增模式開發軟體的優點 避免錯誤放大效應 提早讓使用者見到並操作系統，使用者之意見得提早反映 較小之Increment容易管理、開發及測試 較容易應付發展過程中不斷變動之使用者需求 請解釋敏捷開發中Incremental的意義 將一個大專案切割成數個小專案，每個小專案會產生一部份可執行的軟體，整個系統依此程序漸次完成 請解釋敏捷開發中Iteration的意義 將一個大專案切割成數個小專案，每個小專案約一到四週，進行分析、設計、製作、測試工作，最後產生可執行之軟體，加到系統當中 使用者角色(User Role)有哪些屬性？ 目的 使用頻率 軟硬體專業度 領域專業度 類似軟體熟悉度 請列出Release Planning之主要工作 決定滿足條件 估算使用者故事大小 決定迭代時間長度 估算速度 排定使用者故事優先順序 選入使用者故事及交付日期 請解釋Use Case Diagram之用途 用以表現系統之邊界及系統所存在之環境(context) 用以塑模使用者之需求及系統之功能 請列舉看板方法之三個原則 visualization Limit WIP manage flow Activity Diagram的使用時機？ 描述業務流程或工作流程 描述使用者與系統之互動流程 描述操作流程 描述類別中操作之邏輯 資料庫設計之步驟： 需求的搜集與分析 概想資料庫設計 資料模型轉換 實際資料庫設計 以ER模型進行邏輯資料庫設計時，如何處理一對一及多對多的關係？ 一對一：合併兩個實體 多對多：將原關係變成實體，另建兩個一對多的關係以連接原實體 以ER模型進行邏輯資料庫設計時，如何處理實體、屬性及一對多的關係？ 實體：轉換成表格 屬性：轉換成欄位 一對多：將「一」所代表表格之PK，複製到「多」所代表表格中，並設定成FK 正規化之目的？ 資料在新增、修改或刪除時，整個系統相關資料仍能維持正確良好的狀態 正規化規則： 第一正規化：去除多值屬性 第二正規化：去除只與部分主鍵相關欄位 第三正規化：去除除主鍵外有相依關係的欄位 "},"back-end/developing-solutions/agile/user-story.html":{"url":"back-end/developing-solutions/agile/user-story.html","title":"User Story","keywords":"","body":"User Story 估算故事之單位及方法 估算單位 實際工作天 理想工作天 內外若無共識，容易造成誤會 故事點 比較相對大小 衣服大小：S, M, L 易上手，較不精準，且無法運算 估算方法：絕對 vs. 相對 絕對計算 實際工作天、理想工作天 易受主觀意識影響 相對比較 故事點、衣服大小 比絕對容易評估 易達成共識 舉例：兩棟建築物高度比較 估算方法：少數 vs. 多數 少數專家，單獨估算 召集容易，單獨估算 易有偏見或盲點 多人合作，達成共識 截長補短 預估更客觀 以故事點估算之結果紀錄 費氏數列 注意事項 0：\"這故事已完成\" or \"這故事沒啥，幾分鐘內搞定' ?：\"我一點概念都沒有，沒有主意\" 咖啡杯：\"我已經太累了，先休息一下吧\" Planning Poker 什麼是Planning Poker(規劃撲克牌) 又稱為Scrum poker，是一種以共識(consensus-based)為主的估算技術，用以估算user stories的相對大小 為何要使用Planning Poker 可以避免相互干擾 強迫參與者獨立思考 估算準備 多副Scrum poker及會議室 Egg timer Scrum Poker apps 估算之程序 由一個人負責主持會議， 但是不一起玩， 通常由產品負責人(Product Owner) 擔任。 由最熟悉的開發人員來解釋這個待評估項目，團隊成員可以趁機釐清一些事情，最後會由住持人做出總結。 每個人這時候便開始對這個項目做評估， 也就是想要拿出哪個數字出來，來代表評估的值。 想好之後，每個人同時顯示他們所評估的值。 顯示之後，主持人會請最高和最低值的人, 解釋為什麼會是這個答案，困難點或是容易點在哪裡。 重複步驟3-5 ，直到大家達到共識為止，或是大部分的人有相同的答案。 使用Planning Poker的好處 由做事的人共同決定出一個合理客觀的預估結果，有參與感且無怨言。 決定的結果是產品負責人與開發團隊的共識，減少未來針鋒相對、各說各話的情況發生。 每個人都可以瞭解需求，未來每個人都可以擔任實作這個需求的人選，當需要支援時，也隨時可以有人一同開發或備援。 在還沒動手作之前，就可以把需求不明確的部分，有疑慮的部分釐清。 在還沒動手作之前，就可以在團隊中找到大家認同最好最有效率的實作方式。 除非整個開發團隊都是灌水的人，否則這個數字就反映了團隊共同認知的事實，產品負責人可從中了解需求與評估實作中間的落差。 透過比較需求之間複雜度的相對大小，未來產品負責人對評估迭代可能可以承諾完成多少需求，也會有個比較的基底。 "},"front-end/html/":{"url":"front-end/html/","title":"HTML","keywords":"","body":"HTML 網頁欄位架構、表格、form表單等的快速建立方式範例(Emmet套件功能) table>(tr>td*3)*2 form>fieldset>legend{contact US}+(p>label+input)*6 header>h1+small^nav>a*4^video+#left>(h2+p*3)*4^#right>img*3+form^footer div>h1{NEWS}^div+div HTML新標籤 頁面架構標籤 網頁範例 HTML5-頁面整合 請參考pageMix2.jpg 完成 h1+small^nav>a*4^video+#left>(h2+p*3)*4^#right>img*3+form^footer --> 親近自然 擁抱美麗 讓我們迎向大自然 充滿笑聲迴盪在每一天 露營禮節 器材準備 地點推薦 聯絡我們 露營禮節 營帳規格 野炊安全 入山活動 器材準備 細節規劃 任務分配 環境安全 地點推薦 北部地區 中部地區 南部地區 連絡我們 來訪地圖 留言討論 即時通訊 contact US 您的姓名： 電子郵件： 聯絡電話： 出生日期： 居住地區： 露營經驗:陌生 | 新手 | 老經驗 Happy Camp &copy;Copyright 2020 by Your LOGO - XXXX@gmail.com figure, figcaption figure:獨立內容區段描述 figcaption:獨立內容區段描述標題說明 稻田 影音標籤 "},"front-end/html/form.html":{"url":"front-end/html/form.html","title":"form","keywords":"","body":"form contact US Name: Email: Phone: Web: Birthday: Order: Product: Satisfied:OK | GOOD | PERFECT 說明 本範例表單輸入此行快速產生架構：form>fieldset>legend{contact US}+(p>label+input)*6 元素說明： 元素 說明 fieldset 用來對form表單中的控制元件做分組 legend 作為表單的標題，位於fieldset下的第一個 datalist 下拉表單，與list屬性配合 屬性說明： 屬性 說明 required \b使欄位不得為空白 placeholder 讓欄位空白時顯示文字 value 設定初始值 min 設定最小值 max 設定最大值 step 設定每次增減值的單位數 list 下拉表單，與datalist標籤配合 type input元素的類型，詳下表格 類型(type)說明： 類型 說明 text 字元 email Email tel 號碼 url 網址 number 數量 date 日期（會有小月曆） range 可拉的範圍桿 "},"front-end/css.html":{"url":"front-end/css.html","title":"CSS","keywords":"","body":"CSS body{ background-color: #000000;/*black, #000000,#000*/ text-align: center; color: yellow; } 連結外部CSS檔： "}}